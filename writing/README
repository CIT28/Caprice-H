# Writing Part 1

## INSERT INTO
- MFA tracks the artwork in a collections table.
- How INSERT INTO works INSERT INTO collections (title, accession_number, acquired) VALUES ('Title', '11.6152', '1911-08-03')
- Why title cannot be NULL becuase every artwork must have a name to identify it.
- Why accession_number cannot be NULL it’s the internal ID for the piece.
- Why accession_number is UNIQUE no two artworks can share the same accession number
- The INSERT INTO statement is used to insert new records in a table.
- Here are the errors when trying to run
Runtime error near line 38: UNIQUE constraint failed: collections.accession_number (19)
Runtime error near line 42: NOT NULL constraint failed: collections.title (19)
Runtime error near line 46: NOT NULL constraint failed: collections.accession_number (19)
@Avabeast17 ➜ /workspaces/Caprice-H/writing (main) $ 

## Importing CSV

- What .import does it reads rows from a CSV file and puts them into a table in your SQLite database.

- Why we use .mode csv it tells SQL to parse commas, quotes, and newlines the CSV way.


- Delete notes, Deleting “Spring outing” by title worked. The IS NULL delete didn’t remove blank dates because the CSV imported them as empty strings, not real NULL. That’s why IS NULL might not match anything.
- Next will be the deletion notes and cautions

- Always use WHERE with DELETE FROM. No WHERE = you wipe the whole table and we dont want this.

- Date compares work best in YYYY-MM-DD format.

- Deletes are permanent so be sure row IDs aren’t reused, so gaps in id are normal.

Why the FK error happens- I turned PRAGMA foreign_keys = ON, and SQLite blocked it because rows in created still referenced that artist.
Twostep delete process for me was to first delete the artist’s rows from created (child), then delete the artist from artists parent.

# Writing Part 2
* ON DELETE options
    * CASCADE will delete the child rows automatically when the parent is deleted.
    * SET NULL  set the FK column to NULL (only works if the column allows NULL).
    * RESTRICT block the delete if child rows exist.
    * NO ACTION also blocks the delete; in SQLite it behaves the same as RESTRICT.
* Why CASCADE is handy
    * Keeps data clean. Deleting an artist can also remove their rows in created automatically.
* Default ID behavior
    * INTEGER PRIMARY KEY picks the next id as max id + 1.
    * If I delete the highest id, sql can reuse that id on the next insert.
* With AUTOINCREMENT
    * sql never reuses an old id it always goes higher than any id ever used.
    
## Final grouping and review

- Cleaned vote titles using `UPDATE`:
  - `TRIM` removed leading and the trailing spaces.
  - `UPPER` standardized capitalization.
  - Targeted `UPDATE ... WHERE` fixed typos.
- After cleaning, `GROUP BY title` produced exactly what we wanted, four correct groups.    

## CREATE TRIGGER
* A trigger runs automatically before n after an INSERT, UPDATE, or DELETE.
* FOR EACH ROW means the trigger runs once per row affected.
* BEGIN END wraps the sql that the trigger executes.
* OLD.column refers to the row being deleted or updated, which we used to log sales into transactions.

